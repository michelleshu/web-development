---

## Step 3: Display players as rows in Individual Leaderboard

We now need to display the data for each player as a row in the `IndividualLeaderboard` component. Refer to the "Passing State Down to Child Components" section in [Prep 6](../prep/06.md) for instructions on how to do this.

In the `render()` method of `IndividualLeaderboard`, you will need to translate the list of players (passed in as a prop from `Main`), to row elements in the table. Recall that the `.map()` function (described in Prep from this week) can help with rendering out the contents of an array.

You may get an error about each resulting element not having a unique key. Recall that React requires that all identical components or JSX elements be assigned a unique `key` property. When dealing with arrays, we can often use the index in the array as a key. The index is available as the second argument to the function passed to `map`, for instance:

```js
{this.props.players.map((player, index) => {
    return (<Component key={index} player={player} />);
})}
```

(Replace `Component` there with your code for rendering out a row for the player)

When the render function in `IndividualLeaderboard` successfully processes the players' data to table rows, you should see the new players from the `AddPlayer` form being added to the table as they are submitted.

---

## Step 4: Rank the players in Individual Leaderboard

The final step is to sort the players by rank. Luckily, JavaScript provides a built in function to sort arrays that can be used on the fly, similar to `.map`. The function is called `.sort` and can be used in conjunction with `.map` as so:

```js
{this.props.players
    .sort((playerA, playerB) => {
        return playerA.score < playerB.score;
    })
    .map((player, index) => {
        return (<Component key={index} rank={index + 1} player={player} />);
    });
}
```

What this does is say, when comparing playerA and playerB, make playerA show up earlier in the resulting list if playerA has a higher score than playerB. Here's some more information on the `sort` syntax: [Sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)

We can also now use `index + 1` from the map as the rank of the player to display in the rank column.

---

By the end of these instructions, you should have a working Add Player form that adds player data to the Individual Leaderboard section in the ranked order.

---

## Homework

For homework, please complete the `TeamLeaderboard` component. This should follow similar steps that you completed above for `IndividualLeaderboard`, except each row should reflect a team and the scores be the sum of the scores for all players in the team. The team leaderboard should also be ranked with the leading team as the first row.

Hint: It will be easiest to store `teams` as an object (as a sort of dictionary keyed by team name) in the state of `Main.js`, along with players, so you have something like this in the constructor:

```js
constructor(props) {
    super(props);
    this.state = {
        players: [],
        teams: {}
    };

    this.addToPlayers = this.addToPlayers.bind(this);
}
```

`this.state.teams` would have this format so that it is easy to look up team by team name:
```
{
    Red: {
        name: 'Red',
        score: 100
    },
    Blue: {
        name: 'Blue',
        score: 200
    }
}
```

Why an object instead of an array? With an object that is keyed on the team name, it will be easier to update `teams` accordingly whenever additional players are added in `addToPlayers`. With an array, your update method would have to find the right team in the array to update, splice it out, and replace it, every time an update has to be made to keep the immutability of the React state intact.

If `this.state.teams` was an array, your update method might have to look something like this:
```js
updateTeams(newPlayer) {
    const newPlayerTeamName = newPlayer.team;
    const teams = this.state.teams;
    let team;
    let teamIndex;
    for (let i = 0; i < teams.length; i++) {
        if (teams[i].name === newPlayerTeamName) {
            team = teams[i];
            teamIndex = i;
            break;
        }
    }

    let updatedTeam;
    let updatedTeams;
    if (!team) {
        updatedTeam = {
            name: newPlayerTeamName,
            score: newPlayer.score
        };
        updatedTeams = teams.concat(updatedTeam);
    } else {
        updatedTeam = Object.assign({}, team);
        updatedTeam.score += newPlayer.score;
        updatedTeams.teams.splice(teamIndex, 1, updatedTeam);
    }

    this.setState({ teams: updatedTeams });
}
```

Pretty complicated, huh... With an Object, it is much easier, because we can key on team name as such:
```js
updateTeams(newPlayer) {
    const teams = Object.assign({}, this.state.teams);
    const newPlayerTeamName = newPlayer.team;
    const team = Object.assign({}, teams[newPlayerTeamName]);
    
    if (!team.name) {
        team.name = newPlayerTeamName;
    }

    if (!team.score) {
        team.score = 0;
    }
    team.score += newPlayer.score;

    teams[newPlayerTeamName] = team;
    this.setState({ teams: teams });
}
```

We can get a list of the keys in an object with `Object.keys`, and then map them to an array of the object values to use in our templates in `render()`:
```js
{Object.keys(this.props.teams)
    .map((teamName) => this.props.teams[teamName])
    .sort((teamA, teamB) => {
        return teamA.score < teamB.score;
    })
    .map((team, index) => {
        return (<Component key={index} rank={index + 1} team={team} />);
    });
```

----


